<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#3a3a3a">
    <title>è·³æ£‹å¤§å¸« 2026</title>
    <link rel="manifest" id="manifest-placeholder">
    <style>
        /* === æ ¸å¿ƒè®Šæ•¸èˆ‡é…è‰²å®šç¾© === */
        :root {
            --bg-grad: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            --board-bg: #e0c38c;
            --hole-bg: rgba(0,0,0,0.2);
            --line-color: rgba(93, 64, 55, 0.3);
            --piece-shadow: 1px 3px 5px rgba(0,0,0,0.6), inset -2px -4px 6px rgba(0,0,0,0.3);
            
            /* çµ±ä¸€é‚Šæ¡†å¯¬åº¦ï¼Œé¿å…åˆ‡æ›é¢¨æ ¼æ™‚è·³å‹• */
            --border-width: 12px;
            --border-style: solid;
            --border-color: #5d4037;
            
            --safe-top: env(safe-area-inset-top, 0px); 
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            
            --p1-color: radial-gradient(circle at 30% 30%, #ff4d4d, #990000); /* é è¨­ç´… */
            --p6-color: radial-gradient(circle at 30% 30%, #444444, #000000); /* é è¨­é»‘ */
            
            --hint-color: rgba(0, 255, 255, 0.6);
            --anim-speed: 0.6s;
        }

        /* === è¦–è¦ºé¢¨æ ¼å®šç¾© === */
        /* æ³¨æ„ï¼šåªæ”¹è®Šé¡è‰²ã€æè³ªå’Œ border-styleï¼Œåš´ç¦æ”¹è®Š border-width, padding, margin */
        body.t-classic { --bg-grad: radial-gradient(circle, #3e2723 0%, #1a0f0d 100%); --board-bg: #deb887; --line-color: rgba(93, 64, 55, 0.4); --border-style: ridge; --border-color: #6d4c41; }
        body.t-ink { --bg-grad: linear-gradient(to bottom, #cfd9df 0%, #e2ebf0 100%); --board-bg: #f5f5f5; --hole-bg: rgba(0,0,0,0.1); --line-color: rgba(66, 66, 66, 0.2); --border-style: double; --border-color: #424242; }
        body.t-jade { --bg-grad: radial-gradient(circle, #004d40, #00251a); --board-bg: #80cbc4; --hole-bg: rgba(0,77,64,0.3); --line-color: rgba(0, 77, 64, 0.3); --border-style: inset; --border-color: #00695c; }
        body.t-wood { --bg-grad: linear-gradient(135deg, #4e342e, #1b100d); --board-bg: #8d6e63; --hole-bg: rgba(62, 39, 35, 0.4); --line-color: rgba(62, 39, 35, 0.4); --border-style: groove; --border-color: #4e342e; }
        body.t-gold { --bg-grad: radial-gradient(circle, #2b2b2b, #000); --board-bg: #111; --hole-bg: #333; --line-color: rgba(255, 215, 0, 0.3); --border-style: solid; --border-color: #ffd700; }
        body.t-ocean { --bg-grad: linear-gradient(to bottom, #0d47a1, #000051); --board-bg: #1976d2; --hole-bg: rgba(0,0,81,0.3); --line-color: rgba(187, 222, 251, 0.3); --border-style: double; --border-color: #90caf9; }
        body.t-royal { --bg-grad: linear-gradient(135deg, #4a148c, #1a0033); --board-bg: #7b1fa2; --hole-bg: rgba(74, 0, 114, 0.3); --line-color: rgba(225, 190, 231, 0.3); --border-style: solid; --border-color: #4a0072; }
        body.t-beast { --bg-grad: radial-gradient(circle, #d35400, #2c3e50); --board-bg: #e67e22; --hole-bg: rgba(94, 49, 5, 0.4); --line-color: rgba(94, 49, 5, 0.3); --border-style: dashed; --border-color: #8e44ad; }
        body.t-playful { --bg-grad: linear-gradient(120deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%); --board-bg: #fff0f5; --hole-bg: rgba(255, 105, 180, 0.2); --line-color: rgba(255, 105, 180, 0.3); --border-style: dotted; --border-color: #ff69b4; }
        body.t-shan { --bg-grad: linear-gradient(to top, #cfd9df 0%, #e2ebf0 100%); --board-bg: #d7e4e8; --hole-bg: rgba(93, 109, 126, 0.3); --line-color: rgba(93, 109, 126, 0.3); --border-style: double; --border-color: #5d6d7e; }
        body.t-cute { --bg-grad: linear-gradient(to right, #a1c4fd 0%, #c2e9fb 100%); --board-bg: #e0f7fa; --hole-bg: rgba(77, 208, 225, 0.3); --line-color: rgba(77, 208, 225, 0.4); --border-style: solid; --border-color: #b39ddb; }
        body.t-cyber { --bg-grad: repeating-linear-gradient(90deg, #111 0px, #111 2px, #000 2px, #000 40px); --board-bg: #050505; --hole-bg: #1a1a1a; --line-color: rgba(0, 255, 255, 0.3); --border-style: solid; --border-color: #0ff; }
        body.t-sketch { --bg-grad: #fff; --board-bg: #fff; --hole-bg: #eee; --line-color: rgba(34, 34, 34, 0.1); --border-style: solid; --border-color: #222; }
        body.t-dark { --bg-grad: linear-gradient(135deg, #232526, #414345); --board-bg: #333; --hole-bg: #111; --line-color: rgba(119, 119, 119, 0.3); --border-style: solid; --border-color: #555; }

        html, body { height: 100%; width: 100%; overflow: hidden; overscroll-behavior: none; }
        
        body { 
            font-family: "Microsoft JhengHei", "PingFang TC", sans-serif; 
            background: var(--bg-grad); 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center;
            color: white; 
            transition: background 0.5s; 
            touch-action: none; 
            box-sizing: border-box; 
        }

        /* === é ‚éƒ¨ UI æ¨£å¼ === */
        header { 
            width: 100%; height: auto; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; gap: 4px; flex-shrink: 0; 
            z-index: 100; padding: calc(var(--safe-top) + 8px) 0 8px 0; 
            background: rgba(0,0,0,0.3); backdrop-filter: blur(8px); 
            border-bottom: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 10px rgba(0,0,0,0.2); 
            transition: all 0.3s ease;
        }

        .header-top { display: flex; align-items: center; justify-content: center; gap: 15px; width: 95%; max-width: 600px; flex-wrap: wrap;}
        h2 { font-size: 1.1rem; margin: 0; letter-spacing: 1px; text-shadow: 0 2px 4px rgba(0,0,0,0.8); white-space: nowrap; font-weight: 700; }
        .status { color: #f1c40f; font-weight: bold; font-size: 0.85rem; text-shadow: 0 1px 3px rgba(0,0,0,0.9); line-height: 1.4; display: flex; align-items: center; gap: 8px; justify-content: center; width: 100%;}
        .turn-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; border: 1px solid rgba(255,255,255,0.5); vertical-align: middle; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .player-info { display: flex; align-items: center; gap: 4px; font-size: 0.8rem; color: #ddd; background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 10px; }

        .btn-group { display: flex; gap: 8px; align-items: center; margin-top: 5px;}
        /* UI ç©©å®šæ€§ä¿®æ”¹ï¼šè¨­å®š min-width ç¢ºä¿è‹±æ–‡åˆ‡æ›æ™‚ä¸è·³å‹• */
        .btn { 
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); 
            color: #f0f0f0; padding: 5px 12px; border-radius: 20px; 
            cursor: pointer; font-size: 0.85rem; transition: all 0.2s; 
            white-space: nowrap; backdrop-filter: blur(4px); 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            min-width: 80px; /* å¼·åˆ¶æœ€å°å¯¬åº¦ */
            text-align: center;
        }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .btn-red { background: rgba(220, 50, 50, 0.85); border: none; }
        .btn-undo { background: rgba(230, 140, 20, 0.85); border: none; }

        /* === æ©«å‘æ¨¡å¼ UI é©é… === */
        body.is-landscape {
            flex-direction: row; 
            padding-left: var(--safe-left);
            padding-right: var(--safe-right);
            justify-content: center;
        }
        body.is-landscape header {
            width: 160px; 
            height: 100vh; 
            padding: 0;
            border-bottom: none;
            border-right: 1px solid rgba(255,255,255,0.1);
            justify-content: center; 
            flex-direction: column;
            gap: 20px;
            background: rgba(0,0,0,0.4);
        }
        body.is-landscape .header-top { flex-direction: column; width: 100%; gap: 10px; margin: 0; }
        body.is-landscape h2 { white-space: normal; text-align: center; }
        body.is-landscape .status { font-size: 0.9rem; margin-bottom: 10px; text-align: center; flex-direction: column;}
        body.is-landscape .btn-group { flex-direction: column; width: 100%; gap: 15px; }
        body.is-landscape .btn { width: 85%; text-align: center; padding: 10px 0; }

        /* === è¨­å®šé¢æ¿æ¨£å¼ === */
        #settings { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2000; background: rgba(30, 30, 30, 0.95); width: 340px; padding: 20px; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.9); border: 1px solid rgba(255,255,255,0.1); max-height: 90vh; overflow-y: auto; }
        .set-row { margin-bottom: 12px; }
        .flex-split { display: flex; gap: 10px; justify-content: space-between; }
        /* UI ç©©å®šæ€§ä¿®æ”¹ï¼šä½¿ç”¨ flex: 1 1 0 ç¢ºä¿æ¬„ä½å‡åˆ†ï¼Œä¸å—æ–‡å­—é•·åº¦å½±éŸ¿ */
        .flex-split > div { flex: 1 1 0; display: flex; flex-direction: column; width: 0; }
        .vol-row > div { padding: 0 10px; } 
        label { font-size: 0.85rem; margin-bottom: 5px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .vol-hint { color: #f1c40f; font-weight: bold; margin-left: 4px; }
        select, input[type=range] { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #555; background: #222; color: #fff; height: 38px; box-sizing: border-box; }
        input[type=checkbox] { width: 20px; height: 20px; vertical-align: middle; }

        /* === éŠæˆ²å®¹å™¨èˆ‡æ£‹ç›¤ === */
        #game-container { flex-shrink: 1; flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; position: relative; width: 100%; box-sizing: border-box; }
        body.is-landscape #game-container { width: auto; height: 100vh; flex-grow: 0; }
        
        .board-wrap { 
            position: relative; background: var(--board-bg);
            border: var(--border-width) var(--border-style) var(--border-color);
            border-radius: 50%; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.7), inset 0 0 60px rgba(0,0,0,0.2); 
            width: var(--board-size); height: var(--board-size);
            box-sizing: border-box; 
            flex-shrink: 0; transition: all 0.3s ease;
        }
        
        .board-inner { position: relative; width: 100%; height: 100%; }
        
        svg.board-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        circle.hole { fill: var(--hole-bg); transition: fill 0.2s; }
        line.grid-line { stroke: var(--line-color); stroke-width: 2px; stroke-linecap: round; }
        
        /* äº’å‹•å±¤ */
        .piece { 
            position: absolute; width: 4.8%; height: 4.8%; margin: 0; 
            transform: translate(-50%, -50%) scale(0.85); border-radius: 50%; 
            box-shadow: var(--piece-shadow); cursor: pointer; z-index: 10; 
            transition: top var(--anim-speed) cubic-bezier(0.25, 1, 0.5, 1), left var(--anim-speed) cubic-bezier(0.25, 1, 0.5, 1), transform 0.1s; 
        }
        .piece.no-anim { transition: none !important; }

        .piece.selected { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 0 10px #fff; z-index: 100; }
        
        .piece.ghost { 
            opacity: 0.5; 
            pointer-events: none; 
            z-index: 5; 
            box-shadow: none; 
            filter: grayscale(40%);
            border: 2px dashed rgba(255, 255, 255, 0.6);
            transform: translate(-50%, -50%) scale(0.8);
        }
        
        .piece.last-move::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 30%; height: 30%; background: #00e5ff; border-radius: 50%;
            box-shadow: 0 0 4px #000;
        }

        .piece.p1 { background: var(--p1-color); }
        .piece.p6 { background: var(--p6-color); }
        /* æ”¯æ´å…¶ä»–å¤šè‰² ID */
        .piece.p2 { background: var(--p2-color); }
        .piece.p3 { background: var(--p3-color); }
        .piece.p4 { background: var(--p4-color); }
        .piece.p5 { background: var(--p5-color); }

        .hint {
            position: absolute; width: 5%; height: 5%; 
            transform: translate(-50%, -50%); border-radius: 50%;
            background: var(--hint-color); z-index: 5; cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.8; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }

        /* === ç²å‹å®£å‘Šæ¨£å¼ === */
        #win-overlay { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); 
            pointer-events: none; opacity: 0; z-index: 1000; white-space: nowrap; 
            font: 900 2.5em "Microsoft JhengHei", sans-serif; 
            letter-spacing: 6px; color: #fff; -webkit-text-stroke: 1px #fff; 
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff; 
        }
        #win-overlay.show { opacity: 1; animation: win 2.5s ease-in-out infinite, hue 4s linear infinite; }
        @keyframes win { 
            0% { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } 
            20%, 100% { transform: translate(-50%,-50%) rotate(-3deg); opacity: 1; } 
            60% { transform: translate(-50%,-52%) rotate(3deg); } 
        }
        @keyframes hue { to { filter: hue-rotate(360deg); } }

        #rules-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 3000; justify-content: center; align-items: center; }
        .rules-content { background: #2b2b2b; width: 90%; max-width: 500px; border-radius: 12px; padding: 25px; color: #ddd; }
        .rules-content h3 { color: #f1c40f; text-align: center; border-bottom: 1px solid #555; padding-bottom: 10px;}
        .close-rules { width: 100%; padding: 10px; background: #cc0000; color: #fff; border: none; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;}
    </style>
</head>
<body class="t-classic">

<header id="main-header">
    <div class="header-top">
        <h2 id="app-title">è·³æ£‹å¤§å¸« 2026</h2>
        <div class="status">
            <div id="player-indicator" style="display:none; width:100%; justify-content:center; gap:10px; margin-bottom:4px;"></div>
            <div id="msg"><span class="turn-dot" style="background:red"></span> ç´…æ–¹èµ°æ£‹</div>
        </div>
    </div>
    <div class="btn-group">
        <button class="btn" id="btn-settings" onclick="toggleSet()">âš™ï¸ è¨­å®š</button>
        <button class="btn btn-undo" id="btn-undo" onclick="undo()">â†©ï¸ æ‚”æ£‹</button>
        <button class="btn btn-red" id="btn-restart" onclick="restart()">ğŸ”„ é‡é–‹</button>
    </div>
</header>

<div id="settings">
    <div class="set-row flex-split">
        <div>
            <label id="lbl-mode">å°æˆ°æ¨¡å¼</label>
            <select id="mode-sel" onchange="changeMode()">
                <option value="1" selected>ğŸ‘¤ å–®äºº (vs AI)</option>
                <option value="2">ğŸ‘¥ é›™äºº (1v1)</option>
                <option value="3">ğŸ‘ª ä¸‰äºº (æ··æˆ°)</option>
            </select>
        </div>
        <div>
            <label id="lbl-theme">è¦–è¦ºé¢¨æ ¼</label>
            <select id="theme-sel" onchange="changeTheme()">
                <option value="t-classic">ğŸ’ ç¶“å…¸</option>
                <option value="t-ink">ğŸ”ï¸ æ°´å¢¨</option>
                <option value="t-jade">ğŸ“¿ ç¿¡ç¿ </option>
                <option value="t-wood">ğŸªµ ç´…æœ¨</option>
                <option value="t-gold">ğŸ‘‘ é»‘é‡‘</option>
                <option value="t-ocean">ğŸŒŠ æ·±æµ·</option>
                <option value="t-royal">ğŸ›ï¸ ç´«ç¦</option>
                <option value="t-beast">ğŸ¦ é‡ç¸</option>
                <option value="t-playful">ğŸˆ ä¿çš®</option>
                <option value="t-shan">ğŸ–Œï¸ å±±æ°´</option>
                <option value="t-cute">ğŸ¬ å¯æ„›</option>
                <option value="t-cyber">ğŸ¤– è³½åš</option>
                <option value="t-sketch">âœï¸ ç´ æ</option>
                <option value="t-dark">ğŸŒƒ æš—é»‘</option>
            </select>
        </div>
    </div>

    <div class="set-row flex-split">
        <div>
            <label id="lbl-diff">é›»è…¦é›£åº¦</label>
            <select id="diff-sel">
                <option value="easy">ç°¡å–® (2s)</option>
                <option value="medium" selected>ä¸­ç­‰ (4s)</option>
                <option value="hard">å›°é›£ (8s)</option>
            </select>
        </div>
        <div id="side-select-container">
            <label id="lbl-side">å…ˆå¾Œæ‰‹è¨­å®š</label>
            <select id="side-sel" onchange="restart()">
                <option value="1" selected>ğŸ”´ æˆ‘æ–¹å…ˆæ‰‹</option>
                <option value="-1">âš« é›»è…¦å…ˆæ‰‹</option>
            </select>
        </div>
    </div>

    <div class="set-row flex-split">
        <div>
            <label id="lbl-music">èƒŒæ™¯éŸ³æ¨‚</label>
            <select id="music-sel" onchange="changeMusic()">
                <option value="none">ğŸ”‡ éœéŸ³</option>
                <option value="01">ğŸµ æ¨‚æ›² 01</option>
                <option value="02">ğŸµ æ¨‚æ›² 02</option>
                <option value="03" selected>ğŸµ æ¨‚æ›² 03</option>
                <option value="04">ğŸµ æ¨‚æ›² 04</option>
                <option value="05">ğŸµ æ¨‚æ›² 05</option>
                <option value="06">ğŸµ æ¨‚æ›² 06</option>
                <option value="07">ğŸµ æ¨‚æ›² 07</option>
            </select>
        </div>
        <div>
            <label id="lbl-lang">èªè¨€</label>
            <select id="lang-sel" onchange="changeLang()">
                <option value="tw" selected>ç¹ä¸­</option>
                <option value="cn">ç®€ä¸­</option>
                <option value="en">English</option>
            </select>
        </div>
    </div>

    <div class="set-row flex-split vol-row">
        <div>
            <label id="lbl-vol-bgm">éŸ³æ¨‚éŸ³é‡<span id="bgm-val-hint" class="vol-hint">20</span></label>
            <input type="range" id="bgm-vol" min="0" max="100" value="20" oninput="adjBgm()">
        </div>
        <div>
            <label id="lbl-vol-sfx">éŸ³æ•ˆéŸ³é‡<span id="sfx-val-hint" class="vol-hint">50</span></label>
            <input type="range" id="sfx-vol" min="0" max="100" value="50" oninput="adjSfx()">
        </div>
    </div>
    
    <div class="set-row flex-split" style="margin-top:12px; align-items: flex-end;">
        <div style="flex: 1;">
            <label id="lbl-color">ç©å®¶æ£‹è‰²</label>
            <select id="color-sel" onchange="restart()">
            </select>
        </div>
        <div style="flex: 1; padding-left: 10px; display: flex; flex-direction: column; justify-content: flex-end; padding-bottom: 5px;">
            <label style="cursor:pointer; display:flex; align-items:center;">
                <input type="checkbox" id="anim-toggle" checked onchange="toggleAnim()">
                <span id="lbl-anim" style="margin-left:8px; color:#fff;">ç§»å‹•å‹•ç•«</span>
            </label>
        </div>
    </div>
    
    <div class="set-row flex-split" style="margin-top:10px;">
        <div style="flex: 1;">
             <button class="btn" id="btn-rules" onclick="toggleRules()" style="width:100%; background:#2c3e50; padding: 10px; height: 38px;">ğŸ“– è¦å‰‡</button>
        </div>
        <div style="flex: 1;">
             <button class="btn" id="btn-home" onclick="goHome()" style="width:100%; background:#c0392b; padding: 10px; height: 38px;">ğŸ  å›é¦–é </button>
        </div>
    </div>

    <button class="btn" id="btn-done" style="width:100%; background:#444; padding: 10px; margin-top:15px;" onclick="toggleSet()">å®Œæˆè¨­å®š</button>
</div>

<div id="rules-modal">
    <div class="rules-content">
        <h3 id="rules-title">è·³æ£‹è¦å‰‡</h3>
        <ul id="rules-ul-basic" style="padding-left: 20px; line-height: 1.6;">
            <li><b>ç›®æ¨™ï¼š</b>å°‡å·±æ–¹æ‰€æœ‰æ£‹å­ç§»å‹•åˆ°æ­£å°é¢çš„ä¸‰è§’å€åŸŸã€‚</li>
            <li><b>ç§»å‹•ï¼š</b>å¯ç§»å‹•åˆ°ç›¸é„°ç©ºä½ï¼Œæˆ–"è·³é"ç›¸é„°çš„æ£‹å­ï¼ˆä¸åˆ†æ•µæˆ‘ï¼‰ã€‚</li>
            <li><b>é€£è·³ï¼š</b>è‹¥è·³éå¾Œä»æœ‰æ£‹å­å¯è·³ï¼Œå¯é€£çºŒè·³èºã€‚</li>
            <li><b>ç²å‹ï¼š</b>æœ€å…ˆå°‡æ‰€æœ‰æ£‹å­ä½”æ»¿ç›®æ¨™å€åŸŸè€…ç²å‹ã€‚</li>
        </ul>
        <button class="close-rules" id="btn-close-rules" onclick="toggleRules()">é—œé–‰èªªæ˜</button>
    </div>
</div>

<div id="game-container">
    <div class="board-wrap" id="board-wrap">
        <div class="board-inner" id="board">
            <svg class="board-svg" id="board-svg"></svg>
            <div id="ghosts-layer"></div>
            <div id="pieces-layer"></div>
            <div id="hints-layer"></div>
            <div id="win-overlay"></div>
        </div>
    </div>
</div>

<audio id="bgm" loop></audio>

<script>
/* === PWA æ”¯æ´ === */
const manifestJSON = {
    name: "è·³æ£‹å¤§å¸« 2026", short_name: "è·³æ£‹", display: "standalone",
    background_color: "#3a3a3a", theme_color: "#3a3a3a",
    icons: [{"src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNMjUgODAgTDUwIDMwIEw3NSA4MCBaIiBmaWxsPSIjRjAwIi8+PHBhdGggZD0iTTI1IDMwIEw1MCA4MCBMNzUgMzAgWiIgZmlsbD0iIzAwRCIgb3BhY2l0eT0iMC41Ii8+PC9zdmc+", "sizes": "192x192", "type": "image/svg+xml"}]
};
document.getElementById('manifest-placeholder').setAttribute('href', 'data:application/manifest+json;charset=utf-8,' + encodeURIComponent(JSON.stringify(manifestJSON)));

/* === é¡è‰²å®šç¾© (10ç¨®) === */
const PIECE_COLORS = [
    { id: "red", name: "çƒˆç„°ç´…", val: "radial-gradient(circle at 30% 30%, #ff4d4d, #990000)", enName: "Red" },
    { id: "green", name: "æ£®æ—ç¶ ", val: "radial-gradient(circle at 30% 30%, #4dff4d, #009900)", enName: "Green" },
    { id: "blue", name: "å¯¶çŸ³è—", val: "radial-gradient(circle at 30% 30%, #4d4dff, #000099)", enName: "Blue" },
    { id: "yellow", name: "é–ƒè€€é»ƒ", val: "radial-gradient(circle at 30% 30%, #ffff4d, #999900)", enName: "Yellow" },
    { id: "white", name: "çç ç™½", val: "radial-gradient(circle at 30% 30%, #ffffff, #999999)", enName: "White" },
    { id: "black", name: "é»‘æ›œçŸ³", val: "radial-gradient(circle at 30% 30%, #444444, #000000)", enName: "Black" },
    { id: "purple", name: "é­”å¹»ç´«", val: "radial-gradient(circle at 30% 30%, #d500f9, #4a148c)", enName: "Purple" },
    { id: "cyan", name: "éœ“è™¹é’", val: "radial-gradient(circle at 30% 30%, #00e5ff, #006064)", enName: "Cyan" },
    { id: "orange", name: "æ´»åŠ›æ©˜", val: "radial-gradient(circle at 30% 30%, #ff6d00, #e65100)", enName: "Orange" },
    { id: "pink", name: "ç”œå¿ƒç²‰", val: "radial-gradient(circle at 30% 30%, #ff80ab, #c51162)", enName: "Pink" }
];

/* === Web Workerï¼šAI æ ¸å¿ƒ (å¼·åŒ–ç‰ˆ - æ”»æ“Šå‹) === */
const workerScript = `
let ADJ = {}; let JUMP_ADJ = {};
let coords = [];

function buildGraph(c) {
    coords = c;
    ADJ = {}; JUMP_ADJ = {};
    for (let i = 0; i < coords.length; i++) {
        ADJ[i] = []; JUMP_ADJ[i] = [];
        let c1 = coords[i];
        for (let j = 0; j < coords.length; j++) {
            if (i === j) continue;
            let c2 = coords[j];
            let dist = Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
            if (dist < 1.2) ADJ[i].push(j);
        }
    }
    for (let i = 0; i < coords.length; i++) {
        for (let mid of ADJ[i]) {
            let c1 = coords[i], cm = coords[mid];
            let tx = cm.x + (cm.x - c1.x), ty = cm.y + (cm.y - c1.y);
            for (let k = 0; k < coords.length; k++) {
                let ck = coords[k];
                if (Math.abs(ck.x - tx) < 0.1 && Math.abs(ck.y - ty) < 0.1) {
                    JUMP_ADJ[i].push({mid: mid, dest: k}); break;
                }
            }
        }
    }
}

function getAllPossibleMoves(board, startIdx) {
    let visited = new Set();
    let moves = new Set();
    
    // 1. å–®æ­¥
    for (let n of ADJ[startIdx]) {
        if (board[n] === 0) moves.add(n);
    }

    // 2. é€£è·³
    let jumpQueue = [startIdx];
    let jumpVisited = new Set([startIdx]);
    
    while(jumpQueue.length > 0) {
        let curr = jumpQueue.shift();
        for(let jump of JUMP_ADJ[curr]) {
            if (board[jump.mid] !== 0 && board[jump.dest] === 0 && !jumpVisited.has(jump.dest)) {
                jumpVisited.add(jump.dest);
                jumpQueue.push(jump.dest);
                moves.add(jump.dest);
            }
        }
    }
    return Array.from(moves);
}

// è¨ˆç®—æ­å¹¾é‡Œå¾—è·é›¢
function getDist(idx1, targetPoint) {
    let c1 = coords[idx1];
    return Math.sqrt(Math.pow(c1.x - targetPoint.x, 2) + Math.pow(c1.y - targetPoint.y, 2));
}

// åˆ¤æ–·åº§æ¨™æ˜¯å¦åœ¨ç›®æ¨™ä¸‰è§’å€åŸŸå…§ (ç°¡å–®åŠå¾‘åˆ¤æ–·)
function isInTargetZone(idx, targetPoint) {
    return getDist(idx, targetPoint) < 4.5; // ç´„ 4 æ ¼è·é›¢
}

function think(board, player, targetPoint, timeLimit) {
    let myPieces = [];
    for (let i = 0; i < board.length; i++) if (board[i] === player) myPieces.push(i);
    
    let bestMoves = [];
    let bestScore = -Infinity;

    // æ‰¾å‡ºé›¢ç›®æ¨™æœ€é çš„æ£‹å­ (è½å¾Œè€…)ï¼Œç”¨æ–¼åŠ åˆ†
    let maxDist = -1;
    let laggardIdx = -1;
    for(let p of myPieces) {
        let d = getDist(p, targetPoint);
        if(d > maxDist) { maxDist = d; laggardIdx = p; }
    }

    for (let from of myPieces) {
        let moves = getAllPossibleMoves(board, from);
        let distStart = getDist(from, targetPoint);
        let isLaggard = (from === laggardIdx);
        let startInZone = isInTargetZone(from, targetPoint);

        for (let to of moves) {
            let distEnd = getDist(to, targetPoint);
            let moveDist = Math.sqrt(Math.pow(coords[from].x - coords[to].x, 2) + Math.pow(coords[from].y - coords[to].y, 2));
            let endInZone = isInTargetZone(to, targetPoint);
            
            // === æ ¸å¿ƒè©•åˆ†é‚è¼¯ (æ”»æ“Šå‹å„ªåŒ–) ===
            let score = 0;
            let advancement = distStart - distEnd; // æ­£å€¼ä»£è¡¨é è¿‘ç›®æ¨™
            
            // 1. åŸºæœ¬æ¨é€²åˆ†ï¼šå‰é€²è·é›¢ * åŠ æ¬Š
            // è®“é›»è…¦æ¥µåº¦å‚¾å‘æ–¼å¤§å¹…åº¦è·¨è¶Š (è·³èº)
            score += advancement * 100;

            // 2. æ‡²ç½°å¾Œé€€
            if (advancement < 0) {
                // å¦‚æœå·²ç¶“åœ¨ç›®æ¨™å€ï¼Œåš´ç¦å¾Œé€€é›¢é–‹
                if (startInZone && !endInZone) {
                    score -= 50000;
                } else {
                    // ä¸€èˆ¬å¾Œé€€ï¼Œçµ¦äºˆé‡ç½°ï¼Œé™¤éæ˜¯ç‚ºäº†æ­æ©‹
                    score -= 500; 
                }
            }

            // 3. è½å¾Œè€…çå‹µ (æ­æ©‹æˆ°è¡“)
            // å¦‚æœç§»å‹•çš„æ˜¯æœ€å¾Œé¢çš„æ£‹å­ï¼Œä¸”æœ‰å‰é€²ï¼Œçµ¦äºˆé¡å¤–åŠ åˆ†
            if (isLaggard && advancement > 0) {
                score += 300; 
            }

            // 4. è·³èºçå‹µ
            // é¼“å‹µé•·è·é›¢ç§»å‹• (å¤§æ–¼å–®æ­¥è·é›¢)
            if (moveDist > 2.5) { 
                score += 150; 
                score += moveDist * 20; // è·³è¶Šé è¶Šå¥½
            }

            // 5. ç›®æ¨™å€é–å®š
            // å¦‚æœé€™æ­¥æ£‹é€²å…¥äº†ç›®æ¨™å€ï¼Œçµ¦äºˆå·¨é¡çå‹µ
            if (!startInZone && endInZone) {
                score += 2000;
            }
            // å¦‚æœåœ¨ç›®æ¨™å€å…§ç§»å‹•ï¼Œè¶Šæ·±å…¥è¶Šå¥½
            if (startInZone && endInZone && advancement > 0) {
                score += 500;
            }

            // 6. é˜²æ­¢å¡é‚Š (ç¨å¾®å‚¾å‘èµ°ä¸­é–“)
            let distToCenterStart = Math.abs(coords[from].x - 50);
            let distToCenterEnd = Math.abs(coords[to].x - 50);
            if (distToCenterEnd < distToCenterStart) {
                score += 10;
            }

            // 7. éš¨æ©Ÿæ“¾å‹• (æ‰“ç ´å¹³å±€)
            score += Math.random() * 5;

            if (score > bestScore) {
                bestScore = score;
                bestMoves = [{from, to}];
            } else if (Math.abs(score - bestScore) < 0.1) {
                bestMoves.push({from, to});
            }
        }
    }
    
    if (bestMoves.length > 0) {
        return bestMoves[Math.floor(Math.random() * bestMoves.length)];
    }
    return null;
}

self.onmessage = function(e) {
    const { type, data } = e.data;
    if (type === 'init') { 
        buildGraph(data.coords); 
    } else if (type === 'think') {
        const { board, player, target, timeLimit } = data;
        const move = think(board, player, target, timeLimit);
        self.postMessage(move);
    }
};
`;

/* === éŠæˆ²ä¸»ç¨‹å¼ === */
const PIECE_COUNT = 10;
let boardCoords = []; 
let boardState = []; 
let adjList = []; 
let currentPlayer = 1;
let players = []; 
let historyStack = [];
let selectedPiece = -1;
let validMoves = [];
let isAnimating = false;
let worker;
let isAiThinking = false;
let currentLang = 'tw';
let lastMovedPiece = -1;
let aiTimerInterval = null;
let animEnabled = true;

const ZONE_CONFIG = {
    1: { id: 1, name: "Bottom", filter: c => c.r >= 5, center: {q:0, r:6} }, 
    2: { id: 2, name: "BottomRight", filter: c => c.q >= 5, center: {q:6, r:0} },
    3: { id: 3, name: "TopRight", filter: c => c.q+c.r <= -5, center: {q:0, r:-6} },
};

const ZONES = {
    1: { filter: c => c.r >= 5, opposite: 4, target: {q:0, r:-6} },      // ä¸‹
    2: { filter: c => c.q >= 5, opposite: 5, target: {q:-6, r:0} },      // å³ä¸‹
    3: { filter: c => (c.q+c.r) <= -5, opposite: 6, target: {q:6, r:6} },// å³ä¸Š
    4: { filter: c => c.r <= -5, opposite: 1, target: {q:0, r:6} },      // ä¸Š
    5: { filter: c => c.q <= -5, opposite: 2, target: {q:6, r:0} },      // å·¦ä¸Š
    6: { filter: c => (c.q+c.r) >= 5, opposite: 3, target: {q:-6, r:-6}} // å·¦ä¸‹
};

const TRANSLATIONS = {
    tw: { 
        title: "è·³æ£‹å¤§å¸« 2026", 
        thinking: "æ€è€ƒä¸­...", yourTurn: "è«‹èµ°æ£‹",
        lblMode: "å°æˆ°æ¨¡å¼", lblTheme: "è¦–è¦ºé¢¨æ ¼", lblDiff: "é›»è…¦é›£åº¦", lblSide: "å…ˆå¾Œæ‰‹è¨­å®š", lblLang: "èªè¨€", lblMusic: "èƒŒæ™¯éŸ³æ¨‚", lblVolBgm: "éŸ³æ¨‚éŸ³é‡", lblVolSfx: "éŸ³æ•ˆéŸ³é‡", lblColor: "ç©å®¶æ£‹è‰²", lblAnim: "ç§»å‹•å‹•ç•«",
        optMode1: "ğŸ‘¤ å–®äºº (vs AI)", optMode2: "ğŸ‘¥ é›™äºº (1v1)", optMode3: "ğŸ‘ª ä¸‰äºº (æ··æˆ°)",
        optDiffEasy: "ç°¡å–® (2s)", optDiffMed: "ä¸­ç­‰ (4s)", optDiffHard: "å›°é›£ (8s)",
        optSide1: "ğŸ”´ æˆ‘æ–¹å…ˆæ‰‹", optSide2: "âš« é›»è…¦å…ˆæ‰‹",
        btnSettings: "âš™ï¸ è¨­å®š", btnUndo: "â†©ï¸ æ‚”æ£‹", btnRestart: "ğŸ”„ é‡é–‹", btnDone: "å®Œæˆè¨­å®š", btnRules: "ğŸ“– è¦å‰‡", btnHome: "ğŸ  å›é¦–é ", btnCloseRules: "é—œé–‰èªªæ˜",
        rulesTitle: "è·³æ£‹è¦å‰‡",
        rulesList: ["ç›®æ¨™ï¼šå°‡å·±æ–¹æ‰€æœ‰æ£‹å­ç§»å‹•åˆ°æ­£å°é¢çš„ä¸‰è§’å€åŸŸã€‚", "ç§»å‹•ï¼šå¯ç§»å‹•åˆ°ç›¸é„°ç©ºä½ï¼Œæˆ–'è·³é'ç›¸é„°çš„æ£‹å­ã€‚", "é€£è·³ï¼šè‹¥è·³éå¾Œä»æœ‰æ£‹å­å¯è·³ï¼Œå¯é€£çºŒè·³èºã€‚", "ç²å‹ï¼šæœ€å…ˆå°‡æ‰€æœ‰æ£‹å­ä½”æ»¿ç›®æ¨™å€åŸŸè€…ç²å‹ã€‚"],
        themes: ["ğŸ’ ç¶“å…¸", "ğŸ”ï¸ æ°´å¢¨", "ğŸ“¿ ç¿¡ç¿ ", "ğŸªµ ç´…æœ¨", "ğŸ‘‘ é»‘é‡‘", "ğŸŒŠ æ·±æµ·", "ğŸ›ï¸ ç´«ç¦", "ğŸ¦ é‡ç¸", "ğŸˆ ä¿çš®", "ğŸ–Œï¸ å±±æ°´", "ğŸ¬ å¯æ„›", "ğŸ¤– è³½åš", "âœï¸ ç´ æ", "ğŸŒƒ æš—é»‘"],
        musics: ["ğŸ”‡ éœéŸ³", "ğŸµ æ¨‚æ›² 01", "ğŸµ æ¨‚æ›² 02", "ğŸµ æ¨‚æ›² 03", "ğŸµ æ¨‚æ›² 04", "ğŸµ æ¨‚æ›² 05", "ğŸµ æ¨‚æ›² 06", "ğŸµ æ¨‚æ›² 07"],
        colors: ["çƒˆç„°ç´…", "æ£®æ—ç¶ ", "å¯¶çŸ³è—", "é–ƒè€€é»ƒ", "çç ç™½", "é»‘æ›œçŸ³", "é­”å¹»ç´«", "éœ“è™¹é’", "æ´»åŠ›æ©˜", "ç”œå¿ƒç²‰"]
    },
    cn: { 
        title: "è·³æ£‹å¤§å¸ˆ 2026", 
        thinking: "æ€è€ƒä¸­...", yourTurn: "è¯·èµ°æ£‹",
        lblMode: "å¯¹æˆ˜æ¨¡å¼", lblTheme: "è§†è§‰é£æ ¼", lblDiff: "ç”µè„‘éš¾åº¦", lblSide: "å…ˆåæ‰‹è®¾ç½®", lblLang: "è¯­è¨€", lblMusic: "èƒŒæ™¯éŸ³ä¹", lblVolBgm: "éŸ³ä¹éŸ³é‡", lblVolSfx: "éŸ³æ•ˆéŸ³é‡", lblColor: "ç©å®¶æ£‹è‰²", lblAnim: "ç§»åŠ¨åŠ¨ç”»",
        optMode1: "ğŸ‘¤ å•äºº (vs AI)", optMode2: "ğŸ‘¥ åŒäºº (1v1)", optMode3: "ğŸ‘ª ä¸‰äºº (æ··æˆ˜)",
        optDiffEasy: "ç®€å• (2s)", optDiffMed: "ä¸­ç­‰ (4s)", optDiffHard: "å›°éš¾ (8s)",
        optSide1: "ğŸ”´ æˆ‘æ–¹å…ˆæ‰‹", optSide2: "âš« ç”µè„‘å…ˆæ‰‹",
        btnSettings: "âš™ï¸ è®¾ç½®", btnUndo: "â†©ï¸ æ‚”æ£‹", btnRestart: "ğŸ”„ é‡å¼€", btnDone: "å®Œæˆè®¾ç½®", btnRules: "ğŸ“– è§„åˆ™", btnHome: "ğŸ  å›é¦–é¡µ", btnCloseRules: "å…³é—­è¯´æ˜",
        rulesTitle: "è·³æ£‹è§„åˆ™",
        rulesList: ["ç›®æ ‡ï¼šå°†å·±æ–¹æ‰€æœ‰æ£‹å­ç§»åŠ¨åˆ°æ­£å¯¹é¢çš„ä¸‰è§’åŒºåŸŸã€‚", "ç§»åŠ¨ï¼šå¯ç§»åŠ¨åˆ°ç›¸é‚»ç©ºä½ï¼Œæˆ–'è·³è¿‡'ç›¸é‚»çš„æ£‹å­ã€‚", "è¿è·³ï¼šè‹¥è·³è¿‡åä»æœ‰æ£‹å­å¯è·³ï¼Œå¯è¿ç»­è·³è·ƒã€‚", "è·èƒœï¼šæœ€å…ˆå°†æ‰€æœ‰æ£‹å­å æ»¡ç›®æ ‡åŒºåŸŸè€…è·èƒœã€‚"],
        themes: ["ğŸ’ ç»å…¸", "ğŸ”ï¸ æ°´å¢¨", "ğŸ“¿ ç¿¡ç¿ ", "ğŸªµ çº¢æœ¨", "ğŸ‘‘ é»‘é‡‘", "ğŸŒŠ æ·±æµ·", "ğŸ›ï¸ ç´«ç¦", "ğŸ¦ é‡å…½", "ğŸˆ ä¿çš®", "ğŸ–Œï¸ å±±æ°´", "ğŸ¬ å¯çˆ±", "ğŸ¤– èµ›åš", "âœï¸ ç´ æ", "ğŸŒƒ æš—é»‘"],
        musics: ["ğŸ”‡ é™éŸ³", "ğŸµ ä¹æ›² 01", "ğŸµ ä¹æ›² 02", "ğŸµ ä¹æ›² 03", "ğŸµ ä¹æ›² 04", "ğŸµ ä¹æ›² 05", "ğŸµ ä¹æ›² 06", "ğŸµ ä¹æ›² 07"],
        colors: ["çƒˆç„°çº¢", "æ£®æ—ç»¿", "å®çŸ³è“", "é—ªè€€é»„", "çç ç™½", "é»‘æ›œçŸ³", "é­”å¹»ç´«", "éœ“è™¹é’", "æ´»åŠ›æ©˜", "ç”œå¿ƒç²‰"]
    },
    en: { 
        title: "Checkers Master", 
        thinking: "Thinking...", yourTurn: "Your Turn",
        lblMode: "Mode", lblTheme: "Theme", lblDiff: "Difficulty", lblSide: "First Move", lblLang: "Language", lblMusic: "Music", lblVolBgm: "BGM Volume", lblVolSfx: "SFX Volume", lblColor: "Player Color", lblAnim: "Animation",
        optMode1: "ğŸ‘¤ 1 Player (vs AI)", optMode2: "ğŸ‘¥ 2 Players", optMode3: "ğŸ‘ª 3 Players",
        optDiffEasy: "Easy (2s)", optDiffMed: "Medium (4s)", optDiffHard: "Hard (8s)",
        optSide1: "ğŸ”´ Me First", optSide2: "âš« AI First",
        btnSettings: "âš™ï¸ Settings", btnUndo: "â†©ï¸ Undo", btnRestart: "ğŸ”„ Restart", btnDone: "Done", btnRules: "ğŸ“– Rules", btnHome: "ğŸ  Home", btnCloseRules: "Close",
        rulesTitle: "Game Rules",
        rulesList: ["Goal: Move all pieces to the opposite triangle.", "Move: Step to adjacent hole or jump over pieces.", "Multi-jump: Consecutive jumps are allowed.", "Win: First to fill the target area wins."],
        themes: ["ğŸ’ Classic", "ğŸ”ï¸ Ink", "ğŸ“¿ Jade", "ğŸªµ Wood", "ğŸ‘‘ Gold", "ğŸŒŠ Ocean", "ğŸ›ï¸ Royal", "ğŸ¦ Beast", "ğŸˆ Playful", "ğŸ–Œï¸ Shan", "ğŸ¬ Cute", "ğŸ¤– Cyber", "âœï¸ Sketch", "ğŸŒƒ Dark"],
        musics: ["ğŸ”‡ Mute", "ğŸµ Track 01", "ğŸµ Track 02", "ğŸµ Track 03", "ğŸµ Track 04", "ğŸµ Track 05", "ğŸµ Track 06", "ğŸµ Track 07"],
        colors: ["Flame Red", "Forest Green", "Gem Blue", "Shiny Yellow", "Pearl White", "Obsidian", "Magic Purple", "Neon Cyan", "Vivid Orange", "Sweet Pink"]
    }
};

const audio = document.getElementById('bgm'), audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function initBoardGeometry() {
    boardCoords = [];
    for (let q = -8; q <= 8; q++) {
        for (let r = -8; r <= 8; r++) {
            let s = -q - r;
            let count = 0;
            if (Math.abs(q) <= 4) count++;
            if (Math.abs(r) <= 4) count++;
            if (Math.abs(s) <= 4) count++;
            if (count >= 2) addPoint(q, r);
        }
    }
}

function addPoint(q, r) {
    const scale = 3.3; 
    const cx = 50, cy = 50;
    let x = cx + scale * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
    let y = cy + scale * (1.5 * r);
    boardCoords.push({q, r, x, y, idx: boardCoords.length});
}

function initGame() {
    initColorSelect();
    initBoardGeometry();
    initWorker();
    
    adjList = new Array(boardCoords.length).fill(0).map(() => []);
    for(let i=0; i<boardCoords.length; i++) {
        for(let j=i+1; j<boardCoords.length; j++) {
            let c1 = boardCoords[i], c2 = boardCoords[j];
            let dist = Math.abs(c1.q - c2.q) + Math.abs(c1.r - c2.r) + Math.abs((-c1.q-c1.r) - (-c2.q-c2.r));
            if (dist === 2) { adjList[i].push(j); adjList[j].push(i); }
        }
    }
    
    drawBoard();
    restart();
    window.addEventListener('resize', resizeBoard);
    resizeBoard();
}

function initColorSelect() {
    const sel = document.getElementById('color-sel');
    const t = TRANSLATIONS[currentLang];
    sel.innerHTML = '';
    PIECE_COLORS.forEach((c, idx) => {
        let opt = document.createElement('option');
        opt.value = idx;
        opt.text = t.colors[idx];
        if(idx === 0) opt.selected = true; 
        sel.appendChild(opt);
    });
}

function initWorker() {
    const blob = new Blob([workerScript], {type: 'application/javascript'});
    worker = new Worker(URL.createObjectURL(blob));
    worker.postMessage({ type: 'init', data: { coords: boardCoords } });
    worker.onmessage = e => {
        clearInterval(aiTimerInterval);
        isAiThinking = false; 
        
        const move = e.data;
        if (move && move.from !== undefined && move.to !== undefined) {
             makeMove(move.from, move.to);
        } else {
             forceRandomMove();
        }
    };
}

function forceRandomMove() {
    let aiPlayer = players[currentPlayer];
    let myPieces = [];
    boardState.forEach((pid, idx) => { if(pid === aiPlayer.id) myPieces.push(idx); });
    let moves = [];
    myPieces.forEach(from => {
        let ms = calculateMoves(from);
        ms.forEach(to => moves.push({from, to}));
    });
    if(moves.length > 0) {
        let m = moves[Math.floor(Math.random()*moves.length)];
        makeMove(m.from, m.to);
    } else {
        currentPlayer = (currentPlayer + 1) % players.length;
        updateStatus();
    }
}

function resizeBoard() {
    const isLand = window.innerWidth > window.innerHeight && window.innerHeight < 650;
    isLand ? document.body.classList.add('is-landscape') : document.body.classList.remove('is-landscape');
    const wrap = document.getElementById('board-wrap');
    const header = document.getElementById('main-header');
    wrap.style.width = wrap.style.height = wrap.style.marginTop = '';
    header.style.marginRight = '0';
    
    const winW = window.innerWidth, winH = window.innerHeight;
    let finalSize;
    
    if (isLand) {
        header.style.marginRight = '20px';
        finalSize = Math.min(winW - 160 - 40, winH - 40); 
    } else {
        wrap.style.marginTop = '10px';
        finalSize = Math.min(winW - 40, winH - header.offsetHeight - 40);
    }
    wrap.style.setProperty('--board-size', `${Math.max(280, finalSize)}px`);
}

function drawBoard() {
    const svg = document.getElementById('board-svg');
    let html = '';
    for(let i=0; i<boardCoords.length; i++) {
        let p1 = boardCoords[i];
        for(let n of adjList[i]) {
            if(n < i) continue;
            let p2 = boardCoords[n];
            html += `<line x1="${p1.x}%" y1="${p1.y}%" x2="${p2.x}%" y2="${p2.y}%" class="grid-line" />`;
        }
    }
    for(let i=0; i<boardCoords.length; i++) {
        let p = boardCoords[i];
        html += `<circle cx="${p.x}%" cy="${p.y}%" r="1.5%" class="hole" />`;
    }
    svg.innerHTML = html;
}

function setupPlayers() {
    const mode = document.getElementById('mode-sel').value;
    const side = parseInt(document.getElementById('side-sel').value);
    const userColorIdx = parseInt(document.getElementById('color-sel').value);
    
    const p1ColorObj = PIECE_COLORS[userColorIdx];
    document.documentElement.style.setProperty('--p1-color', p1ColorObj.val);
    
    let availColors = PIECE_COLORS.filter((c, i) => i !== userColorIdx);
    let aiColorObj = availColors[Math.floor(Math.random() * availColors.length)];
    document.documentElement.style.setProperty('--p6-color', aiColorObj.val);
    
    const ind = document.getElementById('player-indicator');
    ind.style.display = 'flex';
    ind.innerHTML = `
        <div class="player-info"><span class="turn-dot" style="background:${p1ColorObj.val.split(', ')[1]}"></span> æ‚¨</div>
        <div class="player-info"><span class="turn-dot" style="background:${aiColorObj.val.split(', ')[1]}"></span> é›»è…¦</div>
    `;

    players = [];

    if (mode === "1") { 
        let slots = [1, 2, 3, 4, 5, 6];
        let p1Slot = slots[Math.floor(Math.random() * slots.length)];
        
        let p1Opposite = ZONES[p1Slot].opposite;
        let aiSlots = slots.filter(s => s !== p1Slot && s !== p1Opposite);
        let aiSlot = aiSlots[Math.floor(Math.random() * aiSlots.length)];

        let p1 = { id: 1, type: 'human', name: "æ‚¨", startZone: p1Slot, target: ZONES[p1Slot].target, colorName: p1ColorObj.enName };
        let ai = { id: 6, type: 'ai', name: "é›»è…¦", startZone: aiSlot, target: ZONES[aiSlot].target, colorName: aiColorObj.enName };

        if (side === 1) { 
            players.push(p1);
            players.push(ai);
        } else { 
            players.push(ai);
            players.push(p1);
            
            if (side === -1) {
                document.documentElement.style.setProperty('--p1-color', aiColorObj.val);
                document.documentElement.style.setProperty('--p6-color', p1ColorObj.val);
                ind.innerHTML = `
                    <div class="player-info"><span class="turn-dot" style="background:${aiColorObj.val.split(', ')[1]}"></span> é›»è…¦</div>
                    <div class="player-info"><span class="turn-dot" style="background:${p1ColorObj.val.split(', ')[1]}"></span> æ‚¨</div>
                `;
            }
        }
        document.getElementById('side-select-container').style.display = 'block';

    } else {
        ind.style.display = 'none';
        document.getElementById('side-select-container').style.display = 'none';
        
        // P1 default red (unless changed), others fixed for now based on ID
        // P1=1(Red), P2=6(Black) in mode 2.
        // In mode 3: P1=1(Red), P2=3(Blue), P3=5(White) usually, but logic used specific IDs.
        // Let's deduce color names from PIECE_COLORS based on default ID mapping.
        // ID 1: Red (idx 0)
        // ID 3: Blue (idx 2)
        // ID 5: White (idx 4)
        // ID 6: Black (idx 5)
        
        if (mode === "2") {
            players.push({id: 1, type: 'human', name: "P1", startZone: 1, target: ZONES[1].target, colorName: "Red"});
            players.push({id: 6, type: 'human', name: "P2", startZone: 4, target: ZONES[4].target, colorName: "Black"});
        } else if (mode === "3") {
            players.push({id: 1, type: 'human', name: "P1", startZone: 1, target: ZONES[1].target, colorName: "Red"});
            players.push({id: 3, type: 'human', name: "P2", startZone: 6, target: ZONES[6].target, colorName: "Blue"});
            players.push({id: 5, type: 'human', name: "P3", startZone: 5, target: ZONES[5].target, colorName: "White"});
        }
    }
}

function restart() {
    setupPlayers();
    boardState = new Array(boardCoords.length).fill(0);
    historyStack = [];
    selectedPiece = -1;
    validMoves = [];
    isAnimating = false;
    lastMovedPiece = -1;
    isAiThinking = false;
    clearInterval(aiTimerInterval);
    document.getElementById('ghosts-layer').innerHTML = '';
    document.getElementById('win-overlay').classList.remove('show');
    
    players.forEach(p => {
        let filterFunc = ZONES[p.startZone].filter;
        let startIndices = boardCoords.filter(filterFunc).map(c => c.idx);
        startIndices.forEach(idx => boardState[idx] = p.id);
    });
    
    currentPlayer = 0; 
    updateStatus();
    renderPieces();
    
    setTimeout(checkAiTurn, 500);
}

function renderPieces() {
    const layer = document.getElementById('pieces-layer');
    layer.innerHTML = '';
    
    if (players[currentPlayer].type === 'human') {
        isAiThinking = false;
    }

    boardState.forEach((pid, idx) => {
        if(pid === 0) return;
        const p = boardCoords[idx];
        const el = document.createElement('div');
        
        el.className = `piece p${pid} ${selectedPiece === idx ? 'selected' : ''} ${lastMovedPiece === idx ? 'last-move' : ''}`;
        el.style.left = `${p.x}%`;
        el.style.top = `${p.y}%`;
        el.dataset.idx = idx; 
        
        if (!animEnabled) el.classList.add('no-anim');
        
        if (players[currentPlayer].type === 'human' && players[currentPlayer].id === pid) {
            el.onclick = (e) => { e.stopPropagation(); selectPiece(idx); };
        }
        layer.appendChild(el);
    });
    
    const hintsLayer = document.getElementById('hints-layer');
    hintsLayer.innerHTML = '';
    validMoves.forEach(idx => {
        const p = boardCoords[idx];
        const el = document.createElement('div');
        el.className = 'hint';
        el.style.left = `${p.x}%`;
        el.style.top = `${p.y}%`;
        el.onclick = (e) => { e.stopPropagation(); makeMove(selectedPiece, idx); };
        hintsLayer.appendChild(el);
    });
}

function createGhost(idx, pid, className) {
    const layer = document.getElementById('ghosts-layer');
    const p = boardCoords[idx];
    const el = document.createElement('div');
    el.className = `piece p${pid} ghost ${className}`;
    el.style.left = `${p.x}%`;
    el.style.top = `${p.y}%`;
    layer.appendChild(el);
}

function calculateMoves(idx) {
    let moves = new Set();
    let startCoord = boardCoords[idx];
    
    adjList[idx].forEach(n => { if (boardState[n] === 0) moves.add(n); });

    let queue = [idx];
    let visited = new Set([idx]);
    
    while(queue.length > 0) {
        let curr = queue.shift();
        let currCoord = boardCoords[curr];
        
        adjList[curr].forEach(mid => {
            if (boardState[mid] !== 0) { 
                let mc = boardCoords[mid];
                let tx = mc.q + (mc.q - currCoord.q);
                let ty = mc.r + (mc.r - currCoord.r);
                let destIdx = boardCoords.findIndex(c => c.q === tx && c.r === ty);
                if (destIdx !== -1 && boardState[destIdx] === 0 && !visited.has(destIdx)) {
                    visited.add(destIdx);
                    queue.push(destIdx);
                    moves.add(destIdx);
                }
            }
        });
    }
    return Array.from(moves);
}

function selectPiece(idx) {
    if (isAnimating || isAiThinking) return;
    if (selectedPiece === idx) { selectedPiece = -1; validMoves = []; } 
    else { selectedPiece = idx; validMoves = calculateMoves(idx); playSfx(300); }
    renderPieces();
}

function makeMove(from, to) {
    const movingPlayer = players[currentPlayer];
    const fromCoord = boardCoords[from];
    const toCoord = boardCoords[to];
    
    if (movingPlayer.type === 'human') {
        document.querySelectorAll('.ghost.type-human').forEach(e => e.remove());
        createGhost(from, boardState[from], 'type-human');
    } else {
        document.querySelectorAll('.ghost.type-ai').forEach(e => e.remove());
        createGhost(from, boardState[from], 'type-ai');
    }
    
    if (animEnabled) {
        isAnimating = true;
        const pieceEl = document.querySelector(`.piece[data-idx="${from}"]`);
        if (pieceEl) {
            pieceEl.style.left = `${toCoord.x}%`;
            pieceEl.style.top = `${toCoord.y}%`;
            setTimeout(() => {
                finalizeMove(from, to);
                isAnimating = false;
                checkAiTurn();
            }, 600); 
        } else {
            finalizeMove(from, to);
            isAnimating = false;
            checkAiTurn();
        }
    } else {
        finalizeMove(from, to);
        checkAiTurn();
    }
}

function finalizeMove(from, to) {
    historyStack.push({ board: [...boardState], player: currentPlayer, lastMoved: lastMovedPiece });
    boardState[to] = boardState[from];
    boardState[from] = 0;
    selectedPiece = -1;
    validMoves = [];
    lastMovedPiece = to;
    
    playSfx(500);
    checkWin();
    currentPlayer = (currentPlayer + 1) % players.length;
    
    updateStatus();
    renderPieces();
}

function checkWin() {
    let p = players[currentPlayer];
    let startZone = p.startZone;
    let targetZone = ZONES[startZone].opposite;
    
    let filterFunc = ZONES[targetZone].filter;
    let targetIndices = boardCoords.filter(filterFunc).map(c => c.idx);
    
    if (targetIndices.length > 0) {
        let count = 0;
        targetIndices.forEach(idx => { if (boardState[idx] === p.id) count++; });
        if (count === 10) {
            // === ç²å‹æ•ˆæœ (ç¬¦åˆæ–°éœ€æ±‚) ===
            playWinSfx();
            
            let winText = "";
            const mode = document.getElementById('mode-sel').value;

            if (mode === "1") {
                // å–®äººæ¨¡å¼
                if (p.type === 'human') {
                    winText = "You Win !";
                } else {
                    winText = "You Lose !";
                }
            } else {
                // é›™äºº/ä¸‰äººæ¨¡å¼ (ä½¿ç”¨é¡è‰²åç¨±)
                // å¾ player ç‰©ä»¶ä¸­ç²å–å­˜å¥½çš„é¡è‰²åç¨±
                let colorName = p.colorName || "Player";
                winText = `${colorName} Win !`;
            }

            document.getElementById('win-overlay').innerText = winText;
            document.getElementById('win-overlay').classList.add('show');
            isAiThinking = true; 
        }
    }
}

function checkAiTurn() {
    if (players[currentPlayer].type === 'ai') {
        isAiThinking = true;
        
        const diff = document.getElementById('diff-sel').value;
        const timeLimit = diff === 'easy' ? 2000 : (diff === 'medium' ? 4000 : 8000);
        
        let timeLeft = timeLimit;
        const t = TRANSLATIONS[currentLang];
        
        updateStatus(`${t.thinking} ${(timeLeft/1000).toFixed(1)}s`);
        
        if(aiTimerInterval) clearInterval(aiTimerInterval);
        
        aiTimerInterval = setInterval(() => {
            timeLeft -= 100;
            if (timeLeft < 0) timeLeft = 0;
            updateStatus(`${t.thinking} ${(timeLeft/1000).toFixed(1)}s`);
            if (timeLeft <= 0) clearInterval(aiTimerInterval);
        }, 100);

        let p = players[currentPlayer];
        let tCoord = p.target;
        let targetPos = boardCoords.find(c => c.q === tCoord.q && c.r === tCoord.r);
        
        if (!targetPos) {
             targetPos = {x: 50, y: 50}; 
        }
        
        worker.postMessage({
            type: 'think',
            data: { board: boardState, player: p.id, target: targetPos, timeLimit: timeLimit }
        });
    }
}

function undo() {
    if (isAiThinking || isAnimating || historyStack.length === 0) return;
    let prev = historyStack.pop();
    if (document.getElementById('mode-sel').value === '1' && historyStack.length > 0) {
         prev = historyStack.pop(); 
    }
    boardState = prev.board;
    currentPlayer = prev.player;
    lastMovedPiece = prev.lastMoved || -1;
    selectedPiece = -1;
    validMoves = [];
    document.getElementById('ghosts-layer').innerHTML = '';
    renderPieces();
    updateStatus();
    document.getElementById('win-overlay').classList.remove('show');
}

function updateStatus(customText = null) {
    const t = TRANSLATIONS[currentLang];
    const msgEl = document.getElementById('msg');
    
    if (customText) {
        msgEl.innerHTML = customText;
    } else {
        const p = players[currentPlayer];
        let pName = p.name;
        let colorVar = (p.id === 1) ? getComputedStyle(document.documentElement).getPropertyValue('--p1-color') 
                      : (p.id === 6) ? getComputedStyle(document.documentElement).getPropertyValue('--p6-color')
                      : getComputedStyle(document.documentElement).getPropertyValue(`--p${p.id}-color`);
                      
        let cleanColor = colorVar.trim().replace('radial-gradient(circle at 30% 30%, ', '').replace(')', '').split(',')[0];
        
        let turnText = (currentLang === 'en') ? `${pName}'s Turn` : `${pName} èµ°æ£‹`;
        let colorDot = `<span class="turn-dot" style="background:${cleanColor}"></span>`;
        msgEl.innerHTML = `${colorDot} ${turnText}`;
    }
}

function changeLang() {
    currentLang = document.getElementById('lang-sel').value;
    const t = TRANSLATIONS[currentLang];
    
    document.getElementById('app-title').innerText = t.title;
    document.getElementById('btn-settings').innerText = t.btnSettings;
    document.getElementById('btn-undo').innerText = t.btnUndo;
    document.getElementById('btn-restart').innerText = t.btnRestart;
    document.getElementById('btn-done').innerText = t.btnDone;
    document.getElementById('btn-rules').innerText = t.btnRules;
    document.getElementById('btn-home').innerText = t.btnHome;
    document.getElementById('btn-close-rules').innerText = t.btnCloseRules;
    
    document.getElementById('lbl-mode').innerText = t.lblMode;
    document.getElementById('lbl-theme').innerText = t.lblTheme;
    document.getElementById('lbl-diff').innerText = t.lblDiff;
    document.getElementById('lbl-side').innerText = t.lblSide;
    document.getElementById('lbl-lang').innerText = t.lblLang;
    document.getElementById('lbl-music').innerText = t.lblMusic;
    document.getElementById('lbl-vol-bgm').childNodes[0].nodeValue = t.lblVolBgm;
    document.getElementById('lbl-vol-sfx').childNodes[0].nodeValue = t.lblVolSfx;
    document.getElementById('lbl-color').innerText = t.lblColor;
    document.getElementById('lbl-anim').innerText = t.lblAnim;
    
    const modeSel = document.getElementById('mode-sel');
    modeSel.options[0].text = t.optMode1;
    modeSel.options[1].text = t.optMode2;
    modeSel.options[2].text = t.optMode3;
    
    const diffSel = document.getElementById('diff-sel');
    diffSel.options[0].text = t.optDiffEasy;
    diffSel.options[1].text = t.optDiffMed;
    diffSel.options[2].text = t.optDiffHard;

    const sideSel = document.getElementById('side-sel');
    sideSel.options[0].text = t.optSide1;
    sideSel.options[1].text = t.optSide2;

    const themeSel = document.getElementById('theme-sel');
    for(let i=0; i<themeSel.options.length; i++) {
        themeSel.options[i].text = t.themes[i];
    }
    const musicSel = document.getElementById('music-sel');
    for(let i=0; i<musicSel.options.length; i++) {
        musicSel.options[i].text = t.musics[i];
    }
    
    const colorSel = document.getElementById('color-sel');
    const savedIdx = colorSel.value;
    colorSel.innerHTML = '';
    PIECE_COLORS.forEach((c, idx) => {
        let opt = document.createElement('option');
        opt.value = idx;
        opt.text = t.colors[idx];
        if(idx == savedIdx) opt.selected = true;
        colorSel.appendChild(opt);
    });
    
    document.getElementById('rules-title').innerText = t.rulesTitle;
    const ul = document.getElementById('rules-ul-basic');
    ul.innerHTML = '';
    t.rulesList.forEach(txt => {
        const li = document.createElement('li');
        li.innerText = txt;
        ul.appendChild(li);
    });
    
    updateStatus();
}

function getMp3Path(val) {
    if (val === 'none') return "";
    const baseUrl = "https://johsok.github.io/Games/MP3/";
    return `${baseUrl}${val}.mp3`;
}

function unlockAudio() {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    audio.volume = document.getElementById('bgm-vol').value/100;
    if ((!audio.src || audio.src === "") && document.getElementById('music-sel').value !== 'none') {
        audio.src = getMp3Path(document.getElementById('music-sel').value);
    }
    if(document.getElementById('music-sel').value !== 'none') audio.play().catch(() => {});
}
document.addEventListener('click', unlockAudio, {once:true, capture:true}); 

document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
        audio.pause();
    } else {
        if (document.getElementById('music-sel').value !== 'none') {
            audio.play().catch(() => {});
        }
    }
});

function playSfx(freq, type) { 
    if(audioCtx.state === 'suspended') audioCtx.resume(); 
    const v = document.getElementById('sfx-vol').value/100; if(v <= 0.01) return; 
    const osc = audioCtx.createOscillator(), g = audioCtx.createGain(); 
    osc.connect(g); g.connect(audioCtx.destination); 
    if(type === 'win') {
        // ä¿ç•™èˆŠçš„ win ä½œç‚ºå‚™ç”¨
        osc.type = "square"; osc.frequency.setValueAtTime(523.25, audioCtx.currentTime);
        g.gain.setValueAtTime(v, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
        osc.start(); osc.stop(audioCtx.currentTime+1);
    } else {
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq/2, audioCtx.currentTime + 0.1);
        g.gain.setValueAtTime(v, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.start(); osc.stop(audioCtx.currentTime+0.15);
    }
}

// === å‹åˆ©éŸ³æ•ˆ (å¾ªç’°æ’­æ”¾5æ¬¡) ===
function playWinSfx() { 
    if(audioCtx.state === 'suspended') audioCtx.resume(); 
    const v = document.getElementById('sfx-vol').value/100; if(v <= 0.01) return; 
    
    const notes = [523.25, 659.25, 783.99, 1046.50]; 
    const loops = 5; // å¾ªç’°æ¬¡æ•¸
    const noteSpeed = 0.12; 
    const loopDuration = notes.length * noteSpeed;
    const gap = 0.05; // å¾ªç’°é–“éš”
    
    const now = audioCtx.currentTime; 

    for (let l = 0; l < loops; l++) {
        let startTimeBase = now + (l * (loopDuration + gap));
        
        for (let i = 0; i < notes.length; i++) { 
            const freq = notes[i]; 
            const osc = audioCtx.createOscillator(); 
            const g = audioCtx.createGain(); 
            osc.type = "square"; 
            osc.connect(g); 
            g.connect(audioCtx.destination); 
            const startTime = startTimeBase + i * noteSpeed; 
            osc.frequency.setValueAtTime(freq, startTime); 
            g.gain.setValueAtTime(0, startTime); 
            g.gain.linearRampToValueAtTime(v * 0.2, startTime + 0.05); 
            g.gain.exponentialRampToValueAtTime(0.001, startTime + noteSpeed); 
            osc.start(startTime); 
            osc.stop(startTime + noteSpeed); 
        }
    }
}

function toggleSet() { const s = document.getElementById('settings'); s.style.display = s.style.display==='block'?'none':'block'; }
function toggleRules() { const r = document.getElementById('rules-modal'); r.style.display = r.style.display==='flex'?'none':'flex'; }
function changeTheme() { document.body.className = document.getElementById('theme-sel').value; }
function changeMode() { 
    const mode = document.getElementById('mode-sel').value;
    document.getElementById('side-select-container').style.display = (mode === "1") ? 'block' : 'none';
    restart(); 
}
function adjBgm() { audio.volume = document.getElementById('bgm-vol').value/100; document.getElementById('bgm-val-hint').innerText = document.getElementById('bgm-vol').value; }
function adjSfx() { document.getElementById('sfx-val-hint').innerText = document.getElementById('sfx-vol').value; } 
function changeMusic() {
    const val = document.getElementById('music-sel').value; 
    if(val === 'none') { audio.pause(); audio.src = ""; } 
    else { audio.src = getMp3Path(val); audio.play().catch(()=>{}); } 
}
function toggleAnim() { animEnabled = document.getElementById('anim-toggle').checked; }

function goHome() {
    try { if (window.parent && typeof window.parent.closeGame === 'function') window.parent.closeGame(); } catch (e) { console.error(e); }
}

window.onload = initGame;

document.addEventListener('contextmenu', e => e.preventDefault());
document.onkeydown = function(e) {
    if (e.keyCode == 123) return false;
    if (e.ctrlKey && e.shiftKey && (e.keyCode == 'I'.charCodeAt(0) || e.keyCode == 'C'.charCodeAt(0) || e.keyCode == 'J'.charCodeAt(0))) return false;
    if (e.ctrlKey && (e.keyCode == 'U'.charCodeAt(0) || e.keyCode == 'S'.charCodeAt(0))) return false;
};
console.log("%cç³»çµ±å®‰å…¨ç›£æ§ä¸­", "color: red; font-size: 30px; font-weight: bold;");
</script>
</body>
</html>